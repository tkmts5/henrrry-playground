<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Editor 7×7×7</title>
    <link rel="stylesheet" href="https://unpkg.com/@sakun/system.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            align-items: flex-start;
            background: none !important;
        }

        #container {
            display: flex;
            gap: 1rem;
            padding: 1rem;
            justify-content: center;
            margin: auto;
        }

        h1.title {
            font-family: Chicago_12;
            font-size: 1.2em !important
        }

        .field-name {
            font-family: Chicago_12;
            font-size: 1em;
        }

        .window {
            display: flex;
            flex-direction: column;
        }

        .view-btns {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .layer-btns {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            margin: auto;
        }

        .view-btns .btn,
        .layer-btns .btn {
            min-width: 50px;
        }

        .view-btns .btn {
            width: 89.5px;
        }

        .layer-btns .btn {
            min-width: 28px;
            width: 36px;
            padding: 0 8px;
        }

        .view-btns .btn.active,
        .layer-btns .btn.active,
        .view-btns .btn.active:hover,
        .layer-btns .btn.active:hover,
        .view-btns .btn.active:focus,
        .layer-btns .btn.active:focus {
            background: #000 !important;
            color: #fff !important;
            /*border: 2px solid #fff !important;*/
            /*border-image: none !important;*/
            border-radius: 6px;
            /*outline: 2px solid #fff !important;
            outline-offset: -4px;*/
        }

        #gridCanvas {
            display: block;
            margin: 0.5rem auto 1rem auto;
        }

        .palette {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 1rem auto;
            padding: 8px;
            justify-content: center;
            background: #efefef;
        }

        .palette .btn {
            width: 35px;
            height: 35px;
            min-width: 28px;
            padding: 0;
            border: 1px solid #000;
        }

        .palette .btn.selected {
            border-width: 4px;
        }

        .palette .btn.palette-empty {
            border-style: dashed;
        }

        .export-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }

        #dataText {
            font-size: 15px;
            font-family: monospace;
            width: 100%;
            max-width: 325px;
            height: 150px;
            resize: vertical;
            border: 1.5px solid var(--secondary);
            background: #efefef;
            padding: 10px;
        }

        #dataText:focus {
            color: #000;
            background: #efefef;
        }

        #dataText:focus-visible {
            outline: 2px solid #000;
            outline-offset: -2px;
        }

        .hint {
            font-size: 12px;
            color: var(--tertiary);
            margin-top: 6px;
        }

        .window-pane {
            padding: 16px !important;
        }

        #previewContainer {
            width: 320px;
            height: 320px;
            margin: auto;
            background: #c0c0c0;
        }

        #previewContainer canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #cameraParamsDisplay {
            font-family: monospace;
        }

        .window-editor {
            width: 360px;
        }

        .window-preview {
            width: 360px;
        }

        .field-row-view,
        .field-row-layer {
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .field-row-preview-options {
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 8px;
        }

        .window .window-pane {
            overflow: auto;
        }

        .window .window-pane::-webkit-scrollbar {
            display: none;
        }

        .window .window-pane {
            scrollbar-width: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div id="container">
        <div class="window window-editor">
            <div class="title-bar">
                <h1 class="title">Voxel Editor</h1>
            </div>
            <div class="separator"></div>
            <div class="window-pane">
                <section class="field-row field-row-view">
                    <span>View</span>
                    <div class="view-btns">
                        <button type="button" class="btn active" data-view="front">Top</button>
                        <button type="button" class="btn" data-view="side">Side</button>
                        <button type="button" class="btn" data-view="top">Front</button>
                    </div>
                </section>
                <section class="field-row field-row-layer">
                    <span>Layer</span>
                    <div class="layer-btns" id="layerBtns"></div>
                </section>
                <canvas id="gridCanvas" width="325" height="325"></canvas>
                <div class="palette" id="palette"></div>
                <span class="field-name">Export / Import</span>
                <div class="export-row">
                    <textarea id="dataText"></textarea>
                </div>
            </div>
        </div>
        <div class="window window-preview">
            <div class="title-bar">
                <h1 class="title">3D Preview</h1>
            </div>
            <div class="separator"></div>
            <div class="window-pane">
                <div id="previewContainer"></div>
                <pre id="cameraParamsDisplay"
                    style="margin: 8px 0; padding: 8px; font-size: 11px; background: #f5f5f5; border-radius: 4px; overflow: auto; max-height: 120px; user-select: text; -webkit-user-select: text; cursor: pointer;"
                    title="Click to copy"></pre>
                
                <section class="field-row field-row-preview-options">
                    <label for="zoomSelect">Zoom:</label>
                    <select id="zoomSelect">
                        <option value="12">Close-up</option>
                        <option value="18">Normal</option>
                        <option value="28" selected>Long-shot</option>
                    </select>
                </section>
                <section class="field-row field-row-preview-options">
                    <label for="easingSelect">Easing:</label>
                    <select id="easingSelect">
                        <option value="on">On</option>
                        <option value="off" selected>Off</option>
                    </select>
                </section>
                <section class="field-row field-row-preview-options">
                    <label for="gifSizeSelect">GIF size:</label>
                    <select id="gifSizeSelect">
                        <option value="320">320</option>
                        <option value="640" selected>640</option>
                        <option value="1200">1200</option>
                    </select>
                </section>
                <section class="field-row field-row-preview-options">
                    <label for="gifFpsSelect">Frame rate:</label>
                    <select id="gifFpsSelect">
                        <option value="10">10 fps</option>
                        <option value="30">30 fps</option>
                        <option value="60" selected>60 fps</option>
                    </select>
                </section>
                <section class="field-row field-row-preview-options"></section>
                <button type="button" class="btn" id="spinBtn">Spin</button>
                <button type="button" class="btn" id="downloadGifBtn">Download GIF</button>
                </section>
    <script src="../js/voxel-export-table.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { GIFEncoder, quantize, applyPalette } from 'https://unpkg.com/gifenc@1.0.3';

        const SIZE = 7;
        const CELL = 325 / SIZE;
        const VOXEL_COUNT = SIZE * SIZE * SIZE;
        const PACKED_LEN = Math.ceil((VOXEL_COUNT * 3) / 10);

        // 0 = ドットなし、1〜7 = 7色（8色に圧縮）
        const PALETTE = [
            null, // 0: 空
            '#000000', '#ffffff', '#0d3b66', '#faf0ca',
            '#f4d35e', '#ee964b', '#f95738'
        ];

        const voxels = new Uint8Array(VOXEL_COUNT);
        let viewMode = 'front';
        let layer = 0;
        let selectedColor = 1;
        const lastLayerByView = { front: 0, side: 0, top: 0 };
        let copiedLayerData = null;
        let shiftOverflowData = null;

        function index(x, y, z) {
            return x + SIZE * y + SIZE * SIZE * z;
        }

        function getVoxel(x, y, z) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return 0;
            return voxels[index(x, y, z)];
        }

        function setVoxel(x, y, z, colorIndex) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return;
            voxels[index(x, y, z)] = Math.max(0, Math.min(7, colorIndex));
        }

        function gridToVoxel(gridX, gridY) {
            if (gridX < 0 || gridX >= SIZE || gridY < 0 || gridY >= SIZE) return null;
            if (viewMode === 'front') return { x: gridX, y: layer, z: gridY };
            if (viewMode === 'side') return { x: layer, y: SIZE - 1 - gridY, z: SIZE - 1 - gridX };
            return { x: gridX, y: SIZE - 1 - gridY, z: layer };
        }

        const gridCanvas = document.getElementById('gridCanvas');
        const ctx = gridCanvas.getContext('2d');

        function drawGrid() {
            ctx.fillStyle = '#efefef';
            ctx.fillRect(0, 0, 325, 325);
            ctx.rect(0, 0, 325, 325);
            ctx.stroke();
            for (let i = 0; i <= SIZE; i++) {
                for (let j = 0; j <= SIZE; j++) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, j * CELL);
                    ctx.lineTo((i + 1) * CELL, j * CELL);
                    ctx.lineTo((i + 1) * CELL, (j + 1) * CELL);
                    ctx.stroke();
                }
            }
            for (let gx = 0; gx < SIZE; gx++) {
                for (let gy = 0; gy < SIZE; gy++) {
                    const v = gridToVoxel(gx, gy);
                    if (!v) continue;
                    const c = getVoxel(v.x, v.y, v.z);
                    if (c === 0) continue;
                    ctx.fillStyle = PALETTE[c];
                    ctx.fillRect(gx * CELL + 3, gy * CELL + 3, CELL - 6, CELL - 6);
                }
            }
        }

        function getGridPos(e) {
            const rect = gridCanvas.getBoundingClientRect();
            const scale = 325 / rect.width;
            const gx = Math.floor((e.clientX - rect.left) * scale / CELL);
            const gy = Math.floor((e.clientY - rect.top) * scale / CELL);
            return { gx, gy };
        }

        function applyCell(gx, gy, dragAction) {
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const newVal = dragAction === 'erase' ? 0 : selectedColor;
            setVoxel(v.x, v.y, v.z, newVal);
        }

        function lineCells(gx0, gy0, gx1, gy1, fn) {
            const n = Math.max(Math.abs(gx1 - gx0), Math.abs(gy1 - gy0), 1);
            for (let i = 0; i <= n; i++) {
                const t = i / n;
                const cx = Math.round(gx0 + t * (gx1 - gx0));
                const cy = Math.round(gy0 + t * (gy1 - gy0));
                if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE) fn(cx, cy);
            }
        }

        let dragging = false;
        let dragAction = 'paint';
        let lastGx = -1, lastGy = -1;

        gridCanvas.addEventListener('mousedown', (e) => {
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const current = getVoxel(v.x, v.y, v.z);
            dragAction = (current !== 0 && current === selectedColor) ? 'erase' : 'paint';
            dragging = true;
            lastGx = gx; lastGy = gy;
            applyCell(gx, gy, dragAction);
            drawGrid();
            update3D();
            updateExportText();
        });

        gridCanvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            if (gx === lastGx && gy === lastGy) return;
            lineCells(lastGx, lastGy, gx, gy, (cx, cy) => applyCell(cx, cy, dragAction));
            lastGx = gx; lastGy = gy;
            drawGrid();
            update3D();
            updateExportText();
        });

        gridCanvas.addEventListener('mouseup', () => { dragging = false; });
        gridCanvas.addEventListener('mouseleave', () => { dragging = false; });

        function switchView(newView) {
            lastLayerByView[viewMode] = layer;
            viewMode = newView;
            layer = lastLayerByView[viewMode];
            viewBtns.forEach(b => b.classList.toggle('active', b.dataset.view === viewMode));
            layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
            drawGrid();
            updateLayerOutline();
        }

        const viewBtns = document.querySelectorAll('.view-btns button');
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        const layerBtns = document.getElementById('layerBtns');
        for (let i = 0; i < SIZE; i++) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn';
            btn.textContent = i;
            btn.dataset.layer = i;
            btn.classList.toggle('active', i === 0);
            btn.addEventListener('click', () => {
                layer = i;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === i));
                drawGrid();
                updateLayerOutline();
            });
            layerBtns.appendChild(btn);
        }

        const paletteEl = document.getElementById('palette');
        PALETTE.forEach((hex, i) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn';
            btn.title = i === 0 ? 'Erase (0)' : `Color ${i}`;
            if (i === 0) {
                btn.style.background = '#f0f0f0';
                btn.classList.add('palette-empty');
            } else {
                btn.style.background = hex;
            }
            btn.classList.toggle('selected', i === 1);
            btn.addEventListener('click', () => {
                selectedColor = i;
                paletteEl.querySelectorAll('button').forEach((b, j) => b.classList.toggle('selected', j === i));
            });
            paletteEl.appendChild(btn);
        });

        function copyCurrentLayer() {
            const data = new Uint8Array(SIZE * SIZE);
            for (let gy = 0; gy < SIZE; gy++) {
                for (let gx = 0; gx < SIZE; gx++) {
                    const v = gridToVoxel(gx, gy);
                    if (v) data[gx + SIZE * gy] = getVoxel(v.x, v.y, v.z) & 7;
                }
            }
            copiedLayerData = data;
        }

        function pasteToCurrentLayer() {
            if (!copiedLayerData || copiedLayerData.length !== SIZE * SIZE) return;
            for (let gy = 0; gy < SIZE; gy++) {
                for (let gx = 0; gx < SIZE; gx++) {
                    const v = gridToVoxel(gx, gy);
                    if (v) setVoxel(v.x, v.y, v.z, copiedLayerData[gx + SIZE * gy]);
                }
            }
            drawGrid();
            update3D();
            updateLayerOutline();
            updateExportText();
        }

        function getViewAxis() {
            if (viewMode === 'front') return 'y';
            if (viewMode === 'side') return 'x';
            return 'z';
        }

        function getLayerSlice(axis, layerIndex) {
            const data = new Uint8Array(SIZE * SIZE);
            if (axis === 'y') {
                for (let z = 0; z < SIZE; z++)
                    for (let x = 0; x < SIZE; x++)
                        data[x + SIZE * z] = getVoxel(x, layerIndex, z) & 7;
            } else if (axis === 'x') {
                for (let z = 0; z < SIZE; z++)
                    for (let y = 0; y < SIZE; y++)
                        data[y + SIZE * z] = getVoxel(layerIndex, y, z) & 7;
            } else {
                for (let y = 0; y < SIZE; y++)
                    for (let x = 0; x < SIZE; x++)
                        data[x + SIZE * y] = getVoxel(x, y, layerIndex) & 7;
            }
            return data;
        }

        function setLayerSlice(axis, layerIndex, data) {
            if (axis === 'y') {
                for (let z = 0; z < SIZE; z++)
                    for (let x = 0; x < SIZE; x++)
                        setVoxel(x, layerIndex, z, data[x + SIZE * z]);
            } else if (axis === 'x') {
                for (let z = 0; z < SIZE; z++)
                    for (let y = 0; y < SIZE; y++)
                        setVoxel(layerIndex, y, z, data[y + SIZE * z]);
            } else {
                for (let y = 0; y < SIZE; y++)
                    for (let x = 0; x < SIZE; x++)
                        setVoxel(x, y, layerIndex, data[x + SIZE * y]);
            }
        }

        const emptyLayer = new Uint8Array(SIZE * SIZE);

        function shiftLayersPositive() {
            const axis = getViewAxis();
            const oldOverflow = shiftOverflowData;
            shiftOverflowData = getLayerSlice(axis, SIZE - 1);
            for (let i = SIZE - 2; i >= 0; i--)
                setLayerSlice(axis, i + 1, getLayerSlice(axis, i));
            setLayerSlice(axis, 0, oldOverflow && oldOverflow.length === SIZE * SIZE ? oldOverflow : emptyLayer);
            drawGrid();
            update3D();
            updateLayerOutline();
            updateExportText();
        }

        function shiftLayersNegative() {
            const axis = getViewAxis();
            const oldOverflow = shiftOverflowData;
            shiftOverflowData = getLayerSlice(axis, 0);
            for (let i = 1; i < SIZE; i++)
                setLayerSlice(axis, i - 1, getLayerSlice(axis, i));
            setLayerSlice(axis, SIZE - 1, oldOverflow && oldOverflow.length === SIZE * SIZE ? oldOverflow : emptyLayer);
            drawGrid();
            update3D();
            updateLayerOutline();
            updateExportText();
        }

        document.addEventListener('keydown', (e) => {
            const tag = document.activeElement?.tagName?.toLowerCase();
            if (tag === 'input' || tag === 'textarea') return;
            if ((e.metaKey || e.ctrlKey) && e.key === 'c') {
                e.preventDefault();
                copyCurrentLayer();
                return;
            }
            if ((e.metaKey || e.ctrlKey) && e.key === 'v') {
                e.preventDefault();
                pasteToCurrentLayer();
                return;
            }
            if ((e.metaKey || e.ctrlKey) && e.key === 'k') {
                e.preventDefault();
                shiftLayersPositive();
                return;
            }
            if ((e.metaKey || e.ctrlKey) && e.key === 'j') {
                e.preventDefault();
                shiftLayersNegative();
                return;
            }
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) - 1 + 3) % 3]);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) + 1) % 3]);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                layer = (layer + 1) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                layer = (layer - 1 + SIZE) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            }
        });

        const dataText = document.getElementById('dataText');

        const TABLE = typeof VOXEL_EXPORT_TABLE !== 'undefined' ? VOXEL_EXPORT_TABLE : '';

        function getExportString() {
            if (!TABLE || TABLE.length < 1024) return '';
            const bits = [];
            for (let i = 0; i < VOXEL_COUNT; i++) {
                const v = (voxels[i] || 0) & 7;
                for (let b = 0; b < 3; b++) bits.push((v >> b) & 1);
            }
            let out = '';
            const BITS_PER_CHAR = 10;
            for (let j = 0; j < PACKED_LEN; j++) {
                const bitsThisChar = (j === PACKED_LEN - 1) ? 9 : BITS_PER_CHAR;
                let val = 0;
                for (let b = 0; b < bitsThisChar; b++) {
                    const bitIndex = j * BITS_PER_CHAR + b;
                    if (bitIndex < bits.length && bits[bitIndex]) val |= 1 << b;
                }
                out += TABLE[val];
            }
            return out;
        }

        function updateExportText() {
            dataText.value = getExportString();
        }

        function applyImportFromString(s) {
            if (s.length !== PACKED_LEN || !TABLE || TABLE.length < 1024) return;
            const bits = [];
            const BITS_PER_CHAR = 10;
            for (let j = 0; j < PACKED_LEN; j++) {
                const idx = TABLE.indexOf(s[j]);
                const val = (idx >= 0 ? idx : 0) & 1023;
                const bitsThisChar = (j === PACKED_LEN - 1) ? 9 : BITS_PER_CHAR;
                for (let b = 0; b < bitsThisChar; b++) bits.push((val >> b) & 1);
            }
            for (let i = 0; i < VOXEL_COUNT; i++) {
                let v = 0;
                for (let b = 0; b < 3; b++) if (bits[i * 3 + b]) v |= 1 << b;
                voxels[i] = v;
            }
            drawGrid();
            update3D();
            updateLayerOutline();
            updateExportText();
        }

        dataText.addEventListener('input', () => {
            const s = dataText.value.replace(/\s/g, '');
            if (s.length === PACKED_LEN && TABLE && TABLE.length >= 1024 && s !== getExportString()) {
                applyImportFromString(s);
            }
        });

        let scene, camera, renderer, controls, meshes, layerOutline, frameLine;
        let spinMode = false;
        let spinStartTime = 0;
        let spinRadius = 12;
        let cameraParamsCopiedFeedbackUntil = 0;
        const spinTarget = new THREE.Vector3(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);
        const SPIN_CYCLE_DURATION = 3000;

        function getCameraOrbitRadius() {
            const el = document.getElementById('zoomSelect');
            return el ? parseInt(el.value, 10) || 12 : 12;
        }

        function applyZoomToCamera() {
            if (!spinMode) return;
            spinRadius = getCameraOrbitRadius();
        }

        function init3D() {
            const container = document.getElementById('previewContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xefefef);
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            camera.position.set(12, 12, 12);
            camera.lookAt(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(320, 320);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            meshes = [];
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const mat = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(PALETTE[1])
                        });
                        const mesh = new THREE.Mesh(geometry, mat);
                        mesh.position.set(x, y, z);
                        mesh.userData = { x, y, z };
                        mesh.visible = false;
                        scene.add(mesh);
                        meshes.push(mesh);
                    }
                }
            }

            const boxSize = SIZE;
            const frameGeom = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(frameGeom);
            frameLine = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 }));
            frameLine.position.set(boxSize / 2 - 0.5, boxSize / 2 - 0.5, boxSize / 2 - 0.5);
            scene.add(frameLine);

            const layerPoints = new Float32Array(12 * 2 * 3);
            layerOutline = new THREE.LineSegments(
                new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(layerPoints, 3)),
                new THREE.LineBasicMaterial({ color: 0x00ffff })
            );
            scene.add(layerOutline);

            const light = new THREE.AmbientLight(0xffffff, 1);
            scene.add(light);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);
            controls.enableDamping = true;

            const cameraParamsEl = document.getElementById('cameraParamsDisplay');
            function formatCameraParam(v) {
                const s = (v >= 0 ? ' ' : '') + v.toFixed(3);
                return s.padStart(8);
            }
            function updateCameraParamsDisplay() {
                if (!cameraParamsEl || !camera || !controls) return;
                if (Date.now() < cameraParamsCopiedFeedbackUntil) {
                    cameraParamsEl.textContent = 'Copied!';
                    return;
                }
                const p = camera.position;
                const px = formatCameraParam(p.x), py = formatCameraParam(p.y), pz = formatCameraParam(p.z);
                cameraParamsEl.title = 'Click to copy';
                cameraParamsEl.textContent =
                    'camera.position.set(' + px + ', ' + py + ', ' + pz + ');'
            }

            function animate() {
                requestAnimationFrame(animate);
                if (spinMode) {
                    const totalElapsed = Date.now() - spinStartTime;
                    const progress = (totalElapsed / SPIN_CYCLE_DURATION) % 1;
                    const eased = getSpinProgress(progress);
                    const angle = Math.floor(totalElapsed / SPIN_CYCLE_DURATION) * Math.PI * 2 + eased * Math.PI * 2;
                    camera.position.x = spinTarget.x + spinRadius * Math.sin(angle);
                    camera.position.y = spinTarget.y;
                    camera.position.z = spinTarget.z + spinRadius * Math.cos(angle);
                    camera.lookAt(spinTarget);
                } else {
                    controls.update();
                }
                updateCameraParamsDisplay();
                renderer.render(scene, camera);
            }
            animate();
        }

        const spinBtn = document.getElementById('spinBtn');
        spinBtn.addEventListener('click', () => {
            spinMode = !spinMode;
            if (spinMode) {
                spinRadius = getCameraOrbitRadius();
                camera.position.y = spinTarget.y;
                camera.position.x = spinTarget.x;
                camera.position.z = spinTarget.z + spinRadius;
                camera.lookAt(spinTarget);
                spinStartTime = Date.now();
            } else {
                spinRadius = 12;
                camera.position.set(12, 12, 12);
                camera.lookAt(spinTarget);
            }
            if (frameLine) frameLine.visible = !spinMode;
            if (layerOutline) layerOutline.visible = !spinMode;
            controls.enabled = !spinMode;
            spinBtn.textContent = spinMode ? 'Stop' : 'Spin';
        });

        document.getElementById('zoomSelect').addEventListener('change', applyZoomToCamera);

        document.getElementById('cameraParamsDisplay').addEventListener('click', () => {
            const el = document.getElementById('cameraParamsDisplay');
            if (!el || !el.textContent) return;
            navigator.clipboard.writeText(el.textContent).then(() => {
                cameraParamsCopiedFeedbackUntil = Date.now() + 1200;
                el.title = 'Copied!';
            }).catch(() => { });
        });

        const PREVIEW_SIZE = 320;

        function getSpinProgress(progress) {
            const useEasing = document.getElementById('easingSelect').value === 'on';
            if (!useEasing) return progress;
            const s1 = progress * progress * (3 - 2 * progress);
            const s2 = s1 * s1 * (3 - 2 * s1);
            return 0.88 * s2 + 0.12 * progress;
        }

        function captureSpinFrame(progress) {
            const eased = getSpinProgress(progress);
            const angle = eased * Math.PI * 2;
            camera.position.x = spinTarget.x + spinRadius * Math.sin(angle);
            camera.position.y = spinTarget.y;
            camera.position.z = spinTarget.z + spinRadius * Math.cos(angle);
            camera.lookAt(spinTarget);
            renderer.render(scene, camera);
        }

        document.getElementById('downloadGifBtn').addEventListener('click', () => {
            spinRadius = getCameraOrbitRadius();
            const gifSize = parseInt(document.getElementById('gifSizeSelect').value, 10);
            const gifFps = parseInt(document.getElementById('gifFpsSelect').value, 10);
            const numFrames = Math.round((SPIN_CYCLE_DURATION / 1000) * gifFps);
            const frameDelayMs = Math.round(1000 / gifFps);

            const prevFrameVisible = frameLine ? frameLine.visible : true;
            const prevLayerVisible = layerOutline ? layerOutline.visible : true;
            if (frameLine) frameLine.visible = false;
            if (layerOutline) layerOutline.visible = false;

            renderer.setSize(gifSize, gifSize);
            renderer.setPixelRatio(1);

            const tmpCanvas = document.createElement('canvas');
            tmpCanvas.width = gifSize;
            tmpCanvas.height = gifSize;
            const tmpCtx = tmpCanvas.getContext('2d');

            const gif = GIFEncoder();
            let palette = null;

            for (let i = 0; i < numFrames; i++) {
                const progress = i / numFrames;
                captureSpinFrame(progress);
                tmpCtx.drawImage(renderer.domElement, 0, 0, gifSize, gifSize);
                const imageData = tmpCtx.getImageData(0, 0, gifSize, gifSize);
                const data = imageData.data;

                if (i === 0) {
                    palette = quantize(data, 256);
                }
                const index = applyPalette(data, palette);
                gif.writeFrame(index, gifSize, gifSize, {
                    palette: i === 0 ? palette : undefined,
                    delay: frameDelayMs
                });
            }

            renderer.setSize(PREVIEW_SIZE, PREVIEW_SIZE);
            renderer.setPixelRatio(window.devicePixelRatio);
            if (frameLine) frameLine.visible = prevFrameVisible;
            if (layerOutline) layerOutline.visible = prevLayerVisible;

            gif.finish();
            const bytes = gif.bytes();
            const blob = new Blob([bytes], { type: 'image/gif' });
            const a = document.createElement('a');
            a.download = 'voxel-spin.gif';
            a.href = URL.createObjectURL(blob);
            a.click();
            URL.revokeObjectURL(a.href);
        });

        function update3D() {
            if (!meshes) return;
            meshes.forEach(mesh => {
                const { x, y, z } = mesh.userData;
                const c = getVoxel(x, y, z);
                mesh.visible = c !== 0;
                if (c !== 0) mesh.material.color.set(PALETTE[c]);
            });
            updateLayerOutline();
        }

        function updateLayerOutline() {
            if (!layerOutline) return;
            const pos = layerOutline.geometry.attributes.position.array;
            const L = layer;
            const lo = -0.5, hi = SIZE - 0.5;
            const L0 = L - 0.5, L1 = L + 0.5;
            let i = 0;
            function seg(ax, ay, az, bx, by, bz) {
                pos[i++] = ax; pos[i++] = ay; pos[i++] = az;
                pos[i++] = bx; pos[i++] = by; pos[i++] = bz;
            }
            if (viewMode === 'front') {
                seg(lo, L0, lo, hi, L0, lo); seg(hi, L0, lo, hi, L0, hi); seg(hi, L0, hi, lo, L0, hi); seg(lo, L0, hi, lo, L0, lo);
                seg(lo, L1, lo, hi, L1, lo); seg(hi, L1, lo, hi, L1, hi); seg(hi, L1, hi, lo, L1, hi); seg(lo, L1, hi, lo, L1, lo);
                seg(lo, L0, lo, lo, L1, lo); seg(hi, L0, lo, hi, L1, lo); seg(hi, L0, hi, hi, L1, hi); seg(lo, L0, hi, lo, L1, hi);
            } else if (viewMode === 'side') {
                seg(L0, lo, lo, L0, hi, lo); seg(L0, hi, lo, L0, hi, hi); seg(L0, hi, hi, L0, lo, hi); seg(L0, lo, hi, L0, lo, lo);
                seg(L1, lo, lo, L1, hi, lo); seg(L1, hi, lo, L1, hi, hi); seg(L1, hi, hi, L1, lo, hi); seg(L1, lo, hi, L1, lo, lo);
                seg(L0, lo, lo, L1, lo, lo); seg(L0, hi, lo, L1, hi, lo); seg(L0, hi, hi, L1, hi, hi); seg(L0, lo, hi, L1, lo, hi);
            } else {
                seg(lo, lo, L0, hi, lo, L0); seg(hi, lo, L0, hi, hi, L0); seg(hi, hi, L0, lo, hi, L0); seg(lo, hi, L0, lo, lo, L0);
                seg(lo, lo, L1, hi, lo, L1); seg(hi, lo, L1, hi, hi, L1); seg(hi, hi, L1, lo, hi, L1); seg(lo, hi, L1, lo, lo, L1);
                seg(lo, lo, L0, lo, lo, L1); seg(hi, lo, L0, hi, lo, L1); seg(hi, hi, L0, hi, hi, L1); seg(lo, hi, L0, lo, hi, L1);
            }
            layerOutline.geometry.attributes.position.needsUpdate = true;
        }

        init3D();
        update3D();
        drawGrid();
        updateExportText();
    </script>
</body>

</html>