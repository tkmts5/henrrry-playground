<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel 8×8×8</title>
    <style>
        * { box-sizing: border-box; }
        html, body { margin: 0; min-height: 100vh; }
        body {
            font-family: "Chicago", "Geneva", system-ui, sans-serif;
            background: #e0e0e0;
            color: #000;
            padding: 12px;
            display: flex;
            flex-direction: column;
            align-items: center;
        }
        h1 {
            font-size: 14px;
            font-weight: normal;
            margin: 0 0 12px 0;
        }
        .main {
            display: flex;
            gap: 16px;
            align-items: flex-start;
        }
        .panel {
            background: #fff;
            border: 1px solid #000;
            padding: 10px;
        }
        .row {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }
        .row:last-child { margin-bottom: 0; }
        .view-btns, .layer-btns { display: flex; gap: 2px; }
        button {
            font-family: inherit;
            font-size: 12px;
            padding: 4px 8px;
            background: #fff;
            border: 1px solid #000;
            cursor: pointer;
        }
        button:hover { background: #e8e8e8; }
        button.active {
            background: #000;
            color: #fff;
        }
        .layer-btns button { min-width: 24px; }
        #gridCanvas {
            display: block;
            border: 1px solid #000;
            background: #fff;
            cursor: crosshair;
        }
        .palette {
            display: flex;
            flex-wrap: wrap;
            gap: 2px;
            margin-top: 8px;
        }
        .palette button {
            width: 24px;
            height: 24px;
            padding: 0;
            border: 1px solid #000;
        }
        .palette button.selected { border-width: 3px; }
        .palette button.palette-empty { border-style: dashed; }
        .export-row {
            margin-top: 10px;
            display: flex;
            flex-direction: column;
            gap: 6px;
        }
        #exportText, #importText {
            font-family: ui-monospace, monospace;
            font-size: 11px;
            width: 320px;
            height: 80px;
            resize: vertical;
            border: 1px solid #000;
            padding: 6px;
        }
        .hint {
            font-size: 11px;
            color: #444;
            margin-top: 8px;
        }
        #previewContainer {
            width: 320px;
            height: 320px;
            border: 1px solid #000;
            background: #c0c0c0;
        }
        #previewContainer canvas { display: block; width: 100%; height: 100%; }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>
<body>
    <h1>Voxel 8×8×8</h1>
    <div class="main">
        <div class="panel">
            <div class="row">
                <span>視点</span>
                <div class="view-btns">
                    <button type="button" data-view="front" class="active">上面</button>
                    <button type="button" data-view="side">側面</button>
                    <button type="button" data-view="top">正面</button>
                </div>
            </div>
            <div class="row">
                <span>レイヤー</span>
                <div class="layer-btns" id="layerBtns"></div>
            </div>
            <canvas id="gridCanvas" width="256" height="256"></canvas>
            <div class="palette" id="palette"></div>
            <div class="export-row">
                <button type="button" id="importBtn">インポート</button>
                <textarea id="importText" placeholder="192文字"></textarea>
            </div>
            <div class="export-row">
                <button type="button" id="exportBtn">エクスポート</button>
                <textarea id="exportText" readonly placeholder="エクスポート結果"></textarea>
                <button type="button" id="copyBtn">コピー</button>
            </div>
            <p class="hint">← → 視点 / ↑ ↓ レイヤー</p>
        </div>
        <div class="panel">
            <div id="previewContainer"></div>
        </div>
    </div>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const SIZE = 8;
        const CELL = 256 / SIZE; // 32px per cell

        // 0 = ドットなし、1〜7 = 7色（8色に圧縮）
        const PALETTE = [
            null, // 0: 空
            '#000000', '#ffffff', '#888888', '#ff0000',
            '#00ff00', '#0000ff', '#ffff00'
        ];

        const voxels = new Uint8Array(SIZE * SIZE * SIZE);
        let viewMode = 'front';
        let layer = 0;
        let selectedColor = 1;
        const lastLayerByView = { front: 0, side: 0, top: 0 };

        function index(x, y, z) {
            return x + SIZE * y + SIZE * SIZE * z;
        }

        function getVoxel(x, y, z) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return 0;
            return voxels[index(x, y, z)];
        }

        function setVoxel(x, y, z, colorIndex) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return;
            voxels[index(x, y, z)] = Math.max(0, Math.min(7, colorIndex));
        }

        function gridToVoxel(gridX, gridY) {
            if (gridX < 0 || gridX >= SIZE || gridY < 0 || gridY >= SIZE) return null;
            if (viewMode === 'front') return { x: gridX, y: layer, z: gridY };
            if (viewMode === 'side') return { x: layer, y: 7 - gridY, z: 7 - gridX };
            return { x: gridX, y: 7 - gridY, z: layer };
        }

        const gridCanvas = document.getElementById('gridCanvas');
        const ctx = gridCanvas.getContext('2d');

        function drawGrid() {
            ctx.fillStyle = '#fff';
            ctx.fillRect(0, 0, 256, 256);
            for (let i = 0; i <= SIZE; i++) {
                ctx.strokeStyle = '#000';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(i * CELL, 0);
                ctx.lineTo(i * CELL, 256);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL);
                ctx.lineTo(256, i * CELL);
                ctx.stroke();
            }
            for (let gx = 0; gx < SIZE; gx++) {
                for (let gy = 0; gy < SIZE; gy++) {
                    const v = gridToVoxel(gx, gy);
                    if (!v) continue;
                    const c = getVoxel(v.x, v.y, v.z);
                    if (c === 0) continue;
                    ctx.fillStyle = PALETTE[c];
                    ctx.fillRect(gx * CELL + 1, gy * CELL + 1, CELL - 1, CELL - 1);
                }
            }
        }

        function getGridPos(e) {
            const rect = gridCanvas.getBoundingClientRect();
            const scale = 256 / rect.width;
            const gx = Math.floor((e.clientX - rect.left) * scale / CELL);
            const gy = Math.floor((e.clientY - rect.top) * scale / CELL);
            return { gx, gy };
        }

        function applyCell(gx, gy, dragAction) {
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const newVal = dragAction === 'erase' ? 0 : selectedColor;
            setVoxel(v.x, v.y, v.z, newVal);
        }

        function lineCells(gx0, gy0, gx1, gy1, fn) {
            const n = Math.max(Math.abs(gx1 - gx0), Math.abs(gy1 - gy0), 1);
            for (let i = 0; i <= n; i++) {
                const t = i / n;
                const cx = Math.round(gx0 + t * (gx1 - gx0));
                const cy = Math.round(gy0 + t * (gy1 - gy0));
                if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE) fn(cx, cy);
            }
        }

        let dragging = false;
        let dragAction = 'paint';
        let lastGx = -1, lastGy = -1;

        gridCanvas.addEventListener('mousedown', (e) => {
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const current = getVoxel(v.x, v.y, v.z);
            dragAction = (current !== 0 && current === selectedColor) ? 'erase' : 'paint';
            dragging = true;
            lastGx = gx; lastGy = gy;
            applyCell(gx, gy, dragAction);
            drawGrid();
            update3D();
        });

        gridCanvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            if (gx === lastGx && gy === lastGy) return;
            lineCells(lastGx, lastGy, gx, gy, (cx, cy) => applyCell(cx, cy, dragAction));
            lastGx = gx; lastGy = gy;
            drawGrid();
            update3D();
        });

        gridCanvas.addEventListener('mouseup', () => { dragging = false; });
        gridCanvas.addEventListener('mouseleave', () => { dragging = false; });

        function switchView(newView) {
            lastLayerByView[viewMode] = layer;
            viewMode = newView;
            layer = lastLayerByView[viewMode];
            viewBtns.forEach(b => b.classList.toggle('active', b.dataset.view === viewMode));
            layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
            drawGrid();
            updateLayerOutline();
        }

        const viewBtns = document.querySelectorAll('.view-btns button');
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        const layerBtns = document.getElementById('layerBtns');
        for (let i = 0; i < SIZE; i++) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.textContent = i;
            btn.dataset.layer = i;
            btn.classList.toggle('active', i === 0);
            btn.addEventListener('click', () => {
                layer = i;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === i));
                drawGrid();
                updateLayerOutline();
            });
            layerBtns.appendChild(btn);
        }

        const paletteEl = document.getElementById('palette');
        PALETTE.forEach((hex, i) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.title = i === 0 ? '消し（0）' : `色 ${i}`;
            if (i === 0) {
                btn.style.background = '#f0f0f0';
                btn.classList.add('palette-empty');
            } else {
                btn.style.background = hex;
            }
            btn.classList.toggle('selected', i === 1);
            btn.addEventListener('click', () => {
                selectedColor = i;
                paletteEl.querySelectorAll('button').forEach((b, j) => b.classList.toggle('selected', j === i));
            });
            paletteEl.appendChild(btn);
        });

        document.addEventListener('keydown', (e) => {
            const tag = document.activeElement?.tagName?.toLowerCase();
            if (tag === 'input' || tag === 'textarea') return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) - 1 + 3) % 3]);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) + 1) % 3]);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                layer = (layer + 1) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                layer = (layer - 1 + SIZE) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            }
        });

        const exportBtn = document.getElementById('exportBtn');
        const exportText = document.getElementById('exportText');
        const copyBtn = document.getElementById('copyBtn');
        const importBtn = document.getElementById('importBtn');
        const importText = document.getElementById('importText');

        const EXPORT_CHAR_BASE = 0xA500;
        const PACKED_LEN = 192;

        function exportData() {
            const v = voxels;
            let out = '';
            for (let g = 0; g < 64; g++) {
                const i = g * 8;
                const v0 = v[i] & 7, v1 = v[i + 1] & 7, v2 = v[i + 2] & 7, v3 = v[i + 3] & 7;
                const v4 = v[i + 4] & 7, v5 = v[i + 5] & 7, v6 = v[i + 6] & 7, v7 = v[i + 7] & 7;
                const b0 = (v0 << 5) | (v1 << 2) | (v2 >> 1);
                const b1 = ((v2 & 1) << 7) | (v3 << 4) | (v4 << 1) | (v5 >> 2);
                const b2 = ((v5 & 3) << 6) | (v6 << 3) | v7;
                out += String.fromCodePoint(EXPORT_CHAR_BASE + b0, EXPORT_CHAR_BASE + b1, EXPORT_CHAR_BASE + b2);
            }
            exportText.value = out;
        }

        function importData() {
            const s = importText.value.replace(/\s/g, '');
            if (s.length !== PACKED_LEN) {
                alert('192文字の文字列を貼り付けてください');
                return;
            }
            for (let g = 0; g < 64; g++) {
                const i = g * 8;
                const b0 = ((s.codePointAt(g * 3) ?? EXPORT_CHAR_BASE) - EXPORT_CHAR_BASE) & 255;
                const b1 = ((s.codePointAt(g * 3 + 1) ?? EXPORT_CHAR_BASE) - EXPORT_CHAR_BASE) & 255;
                const b2 = ((s.codePointAt(g * 3 + 2) ?? EXPORT_CHAR_BASE) - EXPORT_CHAR_BASE) & 255;
                voxels[i] = b0 >> 5;
                voxels[i + 1] = (b0 >> 2) & 7;
                voxels[i + 2] = ((b0 & 3) << 1) | (b1 >> 7);
                voxels[i + 3] = (b1 >> 4) & 7;
                voxels[i + 4] = (b1 >> 1) & 7;
                voxels[i + 5] = ((b1 & 1) << 2) | (b2 >> 6);
                voxels[i + 6] = (b2 >> 3) & 7;
                voxels[i + 7] = b2 & 7;
            }
            drawGrid();
            update3D();
            updateLayerOutline();
        }

        exportBtn.addEventListener('click', exportData);
        copyBtn.addEventListener('click', () => {
            exportData();
            exportText.select();
            navigator.clipboard.writeText(exportText.value);
        });
        importBtn.addEventListener('click', importData);

        let scene, camera, renderer, controls, meshes, layerOutline;

        function init3D() {
            const container = document.getElementById('previewContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xc0c0c0);
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            camera.position.set(12, 12, 12);
            camera.lookAt(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(320, 320);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            meshes = [];
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const mat = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(PALETTE[1])
                        });
                        const mesh = new THREE.Mesh(geometry, mat);
                        mesh.position.set(x, y, z);
                        mesh.userData = { x, y, z };
                        mesh.visible = false;
                        scene.add(mesh);
                        meshes.push(mesh);
                    }
                }
            }

            const boxSize = SIZE;
            const frameGeom = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(frameGeom);
            const frameLine = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 }));
            frameLine.position.set(boxSize / 2 - 0.5, boxSize / 2 - 0.5, boxSize / 2 - 0.5);
            scene.add(frameLine);

            const layerPoints = new Float32Array(12 * 2 * 3);
            layerOutline = new THREE.LineSegments(
                new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(layerPoints, 3)),
                new THREE.LineBasicMaterial({ color: 0x00ffff })
            );
            scene.add(layerOutline);

            const light = new THREE.AmbientLight(0xffffff, 1);
            scene.add(light);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);
            controls.enableDamping = true;

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        function update3D() {
            if (!meshes) return;
            meshes.forEach(mesh => {
                const { x, y, z } = mesh.userData;
                const c = getVoxel(x, y, z);
                mesh.visible = c !== 0;
                if (c !== 0) mesh.material.color.set(PALETTE[c]);
            });
            updateLayerOutline();
        }

        function updateLayerOutline() {
            if (!layerOutline) return;
            const pos = layerOutline.geometry.attributes.position.array;
            const L = layer;
            const lo = -0.5, hi = 7.5;
            const L0 = L - 0.5, L1 = L + 0.5;
            let i = 0;
            function seg(ax, ay, az, bx, by, bz) {
                pos[i++] = ax; pos[i++] = ay; pos[i++] = az;
                pos[i++] = bx; pos[i++] = by; pos[i++] = bz;
            }
            if (viewMode === 'front') {
                seg(lo, L0, lo, hi, L0, lo); seg(hi, L0, lo, hi, L0, hi); seg(hi, L0, hi, lo, L0, hi); seg(lo, L0, hi, lo, L0, lo);
                seg(lo, L1, lo, hi, L1, lo); seg(hi, L1, lo, hi, L1, hi); seg(hi, L1, hi, lo, L1, hi); seg(lo, L1, hi, lo, L1, lo);
                seg(lo, L0, lo, lo, L1, lo); seg(hi, L0, lo, hi, L1, lo); seg(hi, L0, hi, hi, L1, hi); seg(lo, L0, hi, lo, L1, hi);
            } else if (viewMode === 'side') {
                seg(L0, lo, lo, L0, hi, lo); seg(L0, hi, lo, L0, hi, hi); seg(L0, hi, hi, L0, lo, hi); seg(L0, lo, hi, L0, lo, lo);
                seg(L1, lo, lo, L1, hi, lo); seg(L1, hi, lo, L1, hi, hi); seg(L1, hi, hi, L1, lo, hi); seg(L1, lo, hi, L1, lo, lo);
                seg(L0, lo, lo, L1, lo, lo); seg(L0, hi, lo, L1, hi, lo); seg(L0, hi, hi, L1, hi, hi); seg(L0, lo, hi, L1, lo, hi);
            } else {
                seg(lo, lo, L0, hi, lo, L0); seg(hi, lo, L0, hi, hi, L0); seg(hi, hi, L0, lo, hi, L0); seg(lo, hi, L0, lo, lo, L0);
                seg(lo, lo, L1, hi, lo, L1); seg(hi, lo, L1, hi, hi, L1); seg(hi, hi, L1, lo, hi, L1); seg(lo, hi, L1, lo, lo, L1);
                seg(lo, lo, L0, lo, lo, L1); seg(hi, lo, L0, hi, lo, L1); seg(hi, hi, L0, hi, hi, L1); seg(lo, hi, L0, lo, hi, L1);
            }
            layerOutline.geometry.attributes.position.needsUpdate = true;
        }

        init3D();
        update3D();
        drawGrid();
    </script>
</body>
</html>
