<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Voxel Editor 7×7×7</title>
    <link rel="stylesheet" href="https://unpkg.com/@sakun/system.css" />
    <style>
        * {
            box-sizing: border-box;
        }

        body {
            display: flex;
            flex-wrap: wrap;
            gap: 1rem;
            padding: 1rem;
            align-items: flex-start;
        }

        .window {
            display: flex;
            flex-direction: column;
        }

        .view-btns {
            display: flex;
            gap: 4px;
            flex-wrap: wrap;
        }

        .layer-btns {
            display: flex;
            gap: 4px;
            flex-wrap: nowrap;
            margin: auto;
        }

        .view-btns .btn,
        .layer-btns .btn {
            min-width: 50px;
        }

        .view-btns .btn {
            width: 89.5px;
        }

        .layer-btns .btn {
            min-width: 28px;
            width: 36px;
            padding: 0 8px;
        }

        .view-btns .btn.active,
        .layer-btns .btn.active,
        .view-btns .btn.active:hover,
        .layer-btns .btn.active:hover,
        .view-btns .btn.active:focus,
        .layer-btns .btn.active:focus {
            background: #000 !important;
            color: #fff !important;
            /*border: 2px solid #fff !important;*/
            /*border-image: none !important;*/
            border-radius: 6px;
            /*outline: 2px solid #fff !important;
            outline-offset: -4px;*/
        }

        #gridCanvas {
            display: block;
            margin: 0.5rem auto 1rem auto;
        }

        .palette {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
            margin: 0.5rem auto;
            padding: 8px;
            justify-content: center;
            background: #efefef;
        }

        .palette .btn {
            width: 35px;
            height: 35px;
            min-width: 28px;
            padding: 0;
            border: 1px solid #000;
        }

        .palette .btn.selected {
            border-width: 4px;
        }

        .palette .btn.palette-empty {
            border-style: dashed;
        }

        .export-row {
            display: flex;
            flex-direction: column;
            gap: 6px;
            margin-top: 8px;
        }

        #importBtn,
        #exportBtn {
            margin-top: 8px;
        }

        #exportText,
        #importText {
            font-size: 14px;
            width: 100%;
            max-width: 325px;
            height: 90px;
            resize: vertical;
            border: 1.5px solid var(--secondary);
            background: #efefef;
            padding: 6px;
        }

        #exportText:focus,
        #importText:focus {
            color: #000;
            background: #efefef;
        }

        #exportText:focus-visible,
        #importText:focus-visible {
            outline: 2px solid #000;
        }

        #exportText:focus-visible {
            outline-offset: -2px;
        }

        #exportText:focus-visible {
            outline-offset: -2px;
        }

        .hint {
            font-size: 12px;
            color: var(--tertiary);
            margin-top: 6px;
        }

        .window-pane {
            padding: 16px !important;
        }

        #previewContainer {
            width: 320px;
            height: 320px;
            margin: auto;
            background: #c0c0c0;
        }

        #previewContainer canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        .window-editor {
            width: 360px;
        }

        .window-preview {
            width: 360px;
        }

        .field-row-view,
        .field-row-layer {
            align-items: center;
            flex-wrap: wrap;
            gap: 8px;
        }

        .window .window-pane {
            overflow: hidden;
        }

        .window .window-pane::-webkit-scrollbar {
            display: none;
        }

        .window .window-pane {
            scrollbar-width: none;
        }
    </style>
    <script type="importmap">
    {
        "imports": {
            "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
            "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
        }
    }
    </script>
</head>

<body>
    <div class="window window-editor">
        <div class="title-bar">
            <h1 class="title">Voxel Editor</h1>
        </div>
        <div class="separator"></div>
        <div class="window-pane">
            <section class="field-row field-row-view">
                <span>View</span>
                <div class="view-btns">
                    <button type="button" class="btn active" data-view="front">Top</button>
                    <button type="button" class="btn" data-view="side">Side</button>
                    <button type="button" class="btn" data-view="top">Front</button>
                </div>
            </section>
            <section class="field-row field-row-layer">
                <span>Layer</span>
                <div class="layer-btns" id="layerBtns"></div>
            </section>
            <canvas id="gridCanvas" width="325" height="325"></canvas>
            <div class="palette" id="palette"></div>
            <div class="export-row">
                <button type="button" class="btn" id="importBtn">Import</button>
                <textarea id="importText"></textarea>
            </div>
            <div class="export-row">
                <button type="button" class="btn" id="exportBtn">Export</button>
                <textarea id="exportText" readonly></textarea>
            </div>
        </div>
    </div>
    <div class="window window-preview">
        <div class="title-bar">
            <h1 class="title">3D Preview</h1>
        </div>
        <div class="separator"></div>
        <div class="window-pane">
            <div id="previewContainer"></div>
        </div>
    </div>

    <script src="../js/voxel-export-table.js"></script>
    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';

        const SIZE = 7;
        const CELL = 325 / SIZE;
        const VOXEL_COUNT = SIZE * SIZE * SIZE;
        const PACKED_LEN = Math.ceil((VOXEL_COUNT * 3) / 10);

        // 0 = ドットなし、1〜7 = 7色（8色に圧縮）
        const PALETTE = [
            null, // 0: 空
            '#000000', '#ffffff', '#0d3b66', '#faf0ca',
            '#f4d35e', '#ee964b', '#f95738'
        ];

        const voxels = new Uint8Array(VOXEL_COUNT);
        let viewMode = 'front';
        let layer = 0;
        let selectedColor = 1;
        const lastLayerByView = { front: 0, side: 0, top: 0 };

        function index(x, y, z) {
            return x + SIZE * y + SIZE * SIZE * z;
        }

        function getVoxel(x, y, z) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return 0;
            return voxels[index(x, y, z)];
        }

        function setVoxel(x, y, z, colorIndex) {
            if (x < 0 || x >= SIZE || y < 0 || y >= SIZE || z < 0 || z >= SIZE) return;
            voxels[index(x, y, z)] = Math.max(0, Math.min(7, colorIndex));
        }

        function gridToVoxel(gridX, gridY) {
            if (gridX < 0 || gridX >= SIZE || gridY < 0 || gridY >= SIZE) return null;
            if (viewMode === 'front') return { x: gridX, y: layer, z: gridY };
            if (viewMode === 'side') return { x: layer, y: SIZE - 1 - gridY, z: SIZE - 1 - gridX };
            return { x: gridX, y: SIZE - 1 - gridY, z: layer };
        }

        const gridCanvas = document.getElementById('gridCanvas');
        const ctx = gridCanvas.getContext('2d');

        function drawGrid() {
            ctx.fillStyle = '#efefef';
            ctx.fillRect(0, 0, 325, 325);
            ctx.rect(0, 0, 325, 325);
            ctx.stroke();
            for (let i = 0; i <= SIZE; i++) {
                for (let j = 0; j <= SIZE; j++) {
                    ctx.strokeStyle = '#000';
                    ctx.lineWidth = 0.5;
                    ctx.beginPath();
                    ctx.moveTo(i * CELL, j * CELL);
                    ctx.lineTo((i+1) * CELL, j * CELL);
                    ctx.lineTo((i+1) * CELL, (j+1) * CELL);
                    ctx.stroke();
                }
            }
            for (let gx = 0; gx < SIZE; gx++) {
                for (let gy = 0; gy < SIZE; gy++) {
                    const v = gridToVoxel(gx, gy);
                    if (!v) continue;
                    const c = getVoxel(v.x, v.y, v.z);
                    if (c === 0) continue;
                    ctx.fillStyle = PALETTE[c];
                    ctx.fillRect(gx * CELL + 3, gy * CELL + 3, CELL - 6, CELL - 6);
                }
            }
        }

        function getGridPos(e) {
            const rect = gridCanvas.getBoundingClientRect();
            const scale = 325 / rect.width;
            const gx = Math.floor((e.clientX - rect.left) * scale / CELL);
            const gy = Math.floor((e.clientY - rect.top) * scale / CELL);
            return { gx, gy };
        }

        function applyCell(gx, gy, dragAction) {
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const newVal = dragAction === 'erase' ? 0 : selectedColor;
            setVoxel(v.x, v.y, v.z, newVal);
        }

        function lineCells(gx0, gy0, gx1, gy1, fn) {
            const n = Math.max(Math.abs(gx1 - gx0), Math.abs(gy1 - gy0), 1);
            for (let i = 0; i <= n; i++) {
                const t = i / n;
                const cx = Math.round(gx0 + t * (gx1 - gx0));
                const cy = Math.round(gy0 + t * (gy1 - gy0));
                if (cx >= 0 && cx < SIZE && cy >= 0 && cy < SIZE) fn(cx, cy);
            }
        }

        let dragging = false;
        let dragAction = 'paint';
        let lastGx = -1, lastGy = -1;

        gridCanvas.addEventListener('mousedown', (e) => {
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            const v = gridToVoxel(gx, gy);
            if (!v) return;
            const current = getVoxel(v.x, v.y, v.z);
            dragAction = (current !== 0 && current === selectedColor) ? 'erase' : 'paint';
            dragging = true;
            lastGx = gx; lastGy = gy;
            applyCell(gx, gy, dragAction);
            drawGrid();
            update3D();
        });

        gridCanvas.addEventListener('mousemove', (e) => {
            if (!dragging) return;
            const { gx, gy } = getGridPos(e);
            if (gx < 0 || gx >= SIZE || gy < 0 || gy >= SIZE) return;
            if (gx === lastGx && gy === lastGy) return;
            lineCells(lastGx, lastGy, gx, gy, (cx, cy) => applyCell(cx, cy, dragAction));
            lastGx = gx; lastGy = gy;
            drawGrid();
            update3D();
        });

        gridCanvas.addEventListener('mouseup', () => { dragging = false; });
        gridCanvas.addEventListener('mouseleave', () => { dragging = false; });

        function switchView(newView) {
            lastLayerByView[viewMode] = layer;
            viewMode = newView;
            layer = lastLayerByView[viewMode];
            viewBtns.forEach(b => b.classList.toggle('active', b.dataset.view === viewMode));
            layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
            drawGrid();
            updateLayerOutline();
        }

        const viewBtns = document.querySelectorAll('.view-btns button');
        viewBtns.forEach(btn => {
            btn.addEventListener('click', () => switchView(btn.dataset.view));
        });

        const layerBtns = document.getElementById('layerBtns');
        for (let i = 0; i < SIZE; i++) {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn';
            btn.textContent = i;
            btn.dataset.layer = i;
            btn.classList.toggle('active', i === 0);
            btn.addEventListener('click', () => {
                layer = i;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === i));
                drawGrid();
                updateLayerOutline();
            });
            layerBtns.appendChild(btn);
        }

        const paletteEl = document.getElementById('palette');
        PALETTE.forEach((hex, i) => {
            const btn = document.createElement('button');
            btn.type = 'button';
            btn.className = 'btn';
            btn.title = i === 0 ? 'Erase (0)' : `Color ${i}`;
            if (i === 0) {
                btn.style.background = '#f0f0f0';
                btn.classList.add('palette-empty');
            } else {
                btn.style.background = hex;
            }
            btn.classList.toggle('selected', i === 1);
            btn.addEventListener('click', () => {
                selectedColor = i;
                paletteEl.querySelectorAll('button').forEach((b, j) => b.classList.toggle('selected', j === i));
            });
            paletteEl.appendChild(btn);
        });

        document.addEventListener('keydown', (e) => {
            const tag = document.activeElement?.tagName?.toLowerCase();
            if (tag === 'input' || tag === 'textarea') return;
            if (e.key === 'ArrowLeft') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) - 1 + 3) % 3]);
            } else if (e.key === 'ArrowRight') {
                e.preventDefault();
                const views = ['front', 'side', 'top'];
                switchView(views[(views.indexOf(viewMode) + 1) % 3]);
            } else if (e.key === 'ArrowUp') {
                e.preventDefault();
                layer = (layer + 1) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            } else if (e.key === 'ArrowDown') {
                e.preventDefault();
                layer = (layer - 1 + SIZE) % SIZE;
                lastLayerByView[viewMode] = layer;
                layerBtns.querySelectorAll('button').forEach((b, j) => b.classList.toggle('active', j === layer));
                drawGrid();
                updateLayerOutline();
            }
        });

        const exportBtn = document.getElementById('exportBtn');
        const exportText = document.getElementById('exportText');
        const importBtn = document.getElementById('importBtn');
        const importText = document.getElementById('importText');

        const TABLE = typeof VOXEL_EXPORT_TABLE !== 'undefined' ? VOXEL_EXPORT_TABLE : '';

        function exportData() {
            if (!TABLE || TABLE.length < 1024) {
                alert('Please load the conversion table (voxel-export-table.js).');
                return;
            }
            const bits = [];
            for (let i = 0; i < VOXEL_COUNT; i++) {
                const v = (voxels[i] || 0) & 7;
                for (let b = 0; b < 3; b++) bits.push((v >> b) & 1);
            }
            let out = '';
            const BITS_PER_CHAR = 10;
            for (let j = 0; j < PACKED_LEN; j++) {
                const bitsThisChar = (j === PACKED_LEN - 1) ? 9 : BITS_PER_CHAR;
                let val = 0;
                for (let b = 0; b < bitsThisChar; b++) {
                    const bitIndex = j * BITS_PER_CHAR + b;
                    if (bitIndex < bits.length && bits[bitIndex]) val |= 1 << b;
                }
                out += TABLE[val];
            }
            exportText.value = out;
        }

        function importData() {
            const s = importText.value.replace(/\s/g, '');
            if (s.length !== PACKED_LEN) {
                alert('Paste a string of ' + PACKED_LEN + ' characters.');
                return;
            }
            if (!TABLE || TABLE.length < 1024) {
                alert('Please load the conversion table (voxel-export-table.js).');
                return;
            }
            const bits = [];
            const BITS_PER_CHAR = 10;
            for (let j = 0; j < PACKED_LEN; j++) {
                const idx = TABLE.indexOf(s[j]);
                const val = (idx >= 0 ? idx : 0) & 1023;
                const bitsThisChar = (j === PACKED_LEN - 1) ? 9 : BITS_PER_CHAR;
                for (let b = 0; b < bitsThisChar; b++) bits.push((val >> b) & 1);
            }
            for (let i = 0; i < VOXEL_COUNT; i++) {
                let v = 0;
                for (let b = 0; b < 3; b++) if (bits[i * 3 + b]) v |= 1 << b;
                voxels[i] = v;
            }
            drawGrid();
            update3D();
            updateLayerOutline();
        }

        exportBtn.addEventListener('click', exportData);
        importBtn.addEventListener('click', importData);

        let scene, camera, renderer, controls, meshes, layerOutline;

        function init3D() {
            const container = document.getElementById('previewContainer');
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xefefef);
            camera = new THREE.PerspectiveCamera(50, 1, 0.1, 100);
            camera.position.set(12, 12, 12);
            camera.lookAt(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(320, 320);
            renderer.setPixelRatio(window.devicePixelRatio);
            container.appendChild(renderer.domElement);

            const geometry = new THREE.BoxGeometry(1, 1, 1);
            meshes = [];
            for (let z = 0; z < SIZE; z++) {
                for (let y = 0; y < SIZE; y++) {
                    for (let x = 0; x < SIZE; x++) {
                        const mat = new THREE.MeshBasicMaterial({
                            color: new THREE.Color(PALETTE[1])
                        });
                        const mesh = new THREE.Mesh(geometry, mat);
                        mesh.position.set(x, y, z);
                        mesh.userData = { x, y, z };
                        mesh.visible = false;
                        scene.add(mesh);
                        meshes.push(mesh);
                    }
                }
            }

            const boxSize = SIZE;
            const frameGeom = new THREE.BoxGeometry(boxSize, boxSize, boxSize);
            const edges = new THREE.EdgesGeometry(frameGeom);
            const frameLine = new THREE.LineSegments(edges, new THREE.LineBasicMaterial({ color: 0x666666, linewidth: 1 }));
            frameLine.position.set(boxSize / 2 - 0.5, boxSize / 2 - 0.5, boxSize / 2 - 0.5);
            scene.add(frameLine);

            const layerPoints = new Float32Array(12 * 2 * 3);
            layerOutline = new THREE.LineSegments(
                new THREE.BufferGeometry().setAttribute('position', new THREE.BufferAttribute(layerPoints, 3)),
                new THREE.LineBasicMaterial({ color: 0x00ffff })
            );
            scene.add(layerOutline);

            const light = new THREE.AmbientLight(0xffffff, 1);
            scene.add(light);
            controls = new OrbitControls(camera, renderer.domElement);
            controls.target.set(SIZE / 2 - 0.5, SIZE / 2 - 0.5, SIZE / 2 - 0.5);
            controls.enableDamping = true;

            function animate() {
                requestAnimationFrame(animate);
                controls.update();
                renderer.render(scene, camera);
            }
            animate();
        }

        function update3D() {
            if (!meshes) return;
            meshes.forEach(mesh => {
                const { x, y, z } = mesh.userData;
                const c = getVoxel(x, y, z);
                mesh.visible = c !== 0;
                if (c !== 0) mesh.material.color.set(PALETTE[c]);
            });
            updateLayerOutline();
        }

        function updateLayerOutline() {
            if (!layerOutline) return;
            const pos = layerOutline.geometry.attributes.position.array;
            const L = layer;
            const lo = -0.5, hi = SIZE - 0.5;
            const L0 = L - 0.5, L1 = L + 0.5;
            let i = 0;
            function seg(ax, ay, az, bx, by, bz) {
                pos[i++] = ax; pos[i++] = ay; pos[i++] = az;
                pos[i++] = bx; pos[i++] = by; pos[i++] = bz;
            }
            if (viewMode === 'front') {
                seg(lo, L0, lo, hi, L0, lo); seg(hi, L0, lo, hi, L0, hi); seg(hi, L0, hi, lo, L0, hi); seg(lo, L0, hi, lo, L0, lo);
                seg(lo, L1, lo, hi, L1, lo); seg(hi, L1, lo, hi, L1, hi); seg(hi, L1, hi, lo, L1, hi); seg(lo, L1, hi, lo, L1, lo);
                seg(lo, L0, lo, lo, L1, lo); seg(hi, L0, lo, hi, L1, lo); seg(hi, L0, hi, hi, L1, hi); seg(lo, L0, hi, lo, L1, hi);
            } else if (viewMode === 'side') {
                seg(L0, lo, lo, L0, hi, lo); seg(L0, hi, lo, L0, hi, hi); seg(L0, hi, hi, L0, lo, hi); seg(L0, lo, hi, L0, lo, lo);
                seg(L1, lo, lo, L1, hi, lo); seg(L1, hi, lo, L1, hi, hi); seg(L1, hi, hi, L1, lo, hi); seg(L1, lo, hi, L1, lo, lo);
                seg(L0, lo, lo, L1, lo, lo); seg(L0, hi, lo, L1, hi, lo); seg(L0, hi, hi, L1, hi, hi); seg(L0, lo, hi, L1, lo, hi);
            } else {
                seg(lo, lo, L0, hi, lo, L0); seg(hi, lo, L0, hi, hi, L0); seg(hi, hi, L0, lo, hi, L0); seg(lo, hi, L0, lo, lo, L0);
                seg(lo, lo, L1, hi, lo, L1); seg(hi, lo, L1, hi, hi, L1); seg(hi, hi, L1, lo, hi, L1); seg(lo, hi, L1, lo, lo, L1);
                seg(lo, lo, L0, lo, lo, L1); seg(hi, lo, L0, hi, lo, L1); seg(hi, hi, L0, hi, hi, L1); seg(lo, hi, L0, lo, hi, L1);
            }
            layerOutline.geometry.attributes.position.needsUpdate = true;
        }

        init3D();
        update3D();
        drawGrid();
    </script>
</body>

</html>